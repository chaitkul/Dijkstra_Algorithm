# Importing all the necessary libraries

import numpy as np
import heapq
import cv2

# Creating an empty array from node (0,0) to (600,250)

graph = np.empty((250,600), dtype=object)

for y in range(250):
    for x in range(600):
        graph[y,x] = (x,y)

def move_right(current_node, cost=1): # Function to move the point robot one step to the right
    x,y = current_node
    if x<600:
        child_node = (x+1,y)
        return child_node, cost

def move_left(current_node, cost=1): # Function to move the point robot one step to the left
    x,y = current_node
    if x>0:
        child_node = (x-1,y)
        return child_node, cost

def move_up(current_node, cost=1): # Function to move the point robot one step up
    x,y = current_node
    if y>0:
        child_node = (x,y-1)
        return child_node, cost

def move_down(current_node, cost=1): # Function to move the point robot one step down
    x,y = current_node
    if y<250:
        child_node = (x,y+1)
        return child_node, cost

def move_up_right(current_node, cost=1.4): # Function to move the point robot one step up and one step to the right
    x,y = current_node
    if y>0 and x<600:
        child_node = (x+1,y-1)
        return child_node, cost

def move_down_right(current_node, cost=1.4): # Function to move the point robot one step down and one step to the right
    x,y = current_node
    if y<250 and x<600:
        child_node = (x+1,y+1)
        return child_node, cost

def move_up_left(current_node, cost=1.4): # Function to move the point robot one step up and one step to the left
    x,y = current_node
    if y>0 and x>0:
        child_node = (x-1,y-1)
        return child_node, cost

def move_down_left(current_node, cost=1.4): # Function to move the point robot one step down and one step to the left
    x,y = current_node
    if y<250 and x>0:
        child_node = (x-1,y+1)
        return child_node, cost
        
# Creating a list of action set that consists of all the 8 moves

action_set = [move_right, move_left, move_up, move_down, move_up_right, move_down_right, move_up_left, move_down_left]

# Creating the map using OpenCV

def make_canvas():
    canvas = np.zeros((250, 600, 3), dtype="uint8")

    blue = (255,0,0)
    red = (0,0,255)

    # Obstacle rectangles

    cv2.rectangle(canvas, (95,0), (155,105), red, thickness=-1)
    cv2.rectangle(canvas, (95,145), (155,250), red, thickness=-1)
    cv2.rectangle(canvas, (100, 0), (150,100), blue, thickness=-1)
    cv2.rectangle(canvas, (100,150), (150,250), blue, thickness=-1)

    # Obstacle triangle

    pt1 = (460,25)
    pt2 = (460,225)
    pt3 = (510,125)
    pt4 = (455,246)
    pt5 = (455,4)
    pt6 = (515,125)

    # Drawing 3 lines to crate a triangle

    cv2.line(canvas, pt1, pt2, blue, 1)
    cv2.line(canvas, pt2, pt3, blue, 1)
    cv2.line(canvas, pt3, pt1, blue, 1)
    cv2.line(canvas, pt4, pt5, red, 1)
    cv2.line(canvas, pt5, pt6, red, 1)
    cv2.line(canvas, pt6, pt4, red, 1)

    # Using the fillPoly function to fill the obstacle space

    points1 = np.array([[455,246],[455,4],[515,125]])
    points1 = points1.reshape((-1,1,2))
    cv2.fillPoly(canvas, [points1], red)

    points2 = np.array([[510,125],[460,225],[460,25]])
    points2 = points2.reshape((-1,1,2))
    cv2.fillPoly(canvas, [points2], blue)

    # Obstacle hexagon

    center = (300,125)
    side_length = 75

    # Drawing six lines to create a hexagon

    pts3 = []
    for i in range(6):
        angle_deg = 60 * i
        angle_rad = np.pi / 180 * (angle_deg + 90)
        pt = (int(center[0] + side_length * np.cos(angle_rad)),
            int(center[1] + side_length * np.sin(angle_rad)))
        pts3.append(pt)

    for i in range(6):
        cv2.line(canvas, pts3[i], pts3[(i+1)%6], blue, 1)

    center = (300,125)
    side_length = 81

    pts4 = []
    for i in range(6):
        angle_deg = 60 * i
        angle_rad = np.pi / 180 * (angle_deg + 90)
        pt = (int(center[0] + side_length * np.cos(angle_rad)),
            int(center[1] + side_length * np.sin(angle_rad)))
        pts4.append(pt)

    for i in range(6):
        cv2.line(canvas, pts4[i], pts4[(i+1)%6], red, 1)

    # Using the fillPoly function to fill the obstacle space

    points4 = np.array([[230,85],[230,165],[300,206],[370,165],[370,85],[300,44]])
    points4 = points4.reshape((-1,1,2))
    cv2.fillPoly(canvas, [points4], red)

    points3 = np.array([[300,200],[235,162],[235,87],[300,50],[364,87],[364,162]])
    points3 = points3.reshape((-1,1,2))
    cv2.fillPoly(canvas, [points3], blue)

    # Finding all the nonzero pixels from the canvas and appending them to the list of obstacle points

    obstacle = []
    for y in range(canvas.shape[0]):
        for x in range(canvas.shape[1]):
            if canvas[y,x].any():
                obstacle.append((x,y))

    # Returning the obstacle space and the canvas image

    return obstacle, canvas

obstacle, canvas = make_canvas()
